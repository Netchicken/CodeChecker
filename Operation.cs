using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CodeChecker
{
    using F23.StringSimilarity;

    public class Operation
    {
        public string Text { get; set; }
        public string Text2 { get; set; }
        //files and their contents added to the dictionary
        //   public Dictionary<string, string> AllFiles = new Dictionary<string, string>();

        public List<string> FoundMatches = new List<string>();
        //  public string docPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

        public List<string> ScreenResults = new List<string>();

        //public void ExtractFilePaths()
        //{ //files and their contents added to the dictionary

        //    var files = Directory.EnumerateFiles(ExtractFiles.docPath, "*.cs", SearchOption.AllDirectories);

        //    foreach (var f in files)
        //    {
        //        //filter the folders from the path
        //        if (!f.Contains("Debug") && !f.Contains(".vs") && !f.Contains("packages") && !f.Contains("obj") &&
        //            !f.Contains("Properties") && !f.Contains("Resources") && !f.Contains("Program.cs"))
        //        {
        //            string text = File.ReadAllText(f).ToLower();

        //            //filter the file content
        //            if (!string.IsNullOrEmpty(text) && !text.Contains("<auto-generated>"))
        //            {
        //                AllFiles.Add(f, text);
        //            }
        //        }
        //    }

        //}

        public void RunLev(int LevSize, Boolean IsContains)
        {
            List<double> LEVDistance = new List<double>();

            //holds a record of  matches to stop them appearing twice
            List<string> NotRepeatingMatches = new List<string>();
            int count = 0;
            var Lev = new Levenshtein();
            try
            {
                foreach (var text in ExtractFiles.AllFiles)
                {
                    //get a short path without the filename for path comparisons
                    string FolderPathNoFile1 = GetShortPath(text.Key);
                    //short string to appear in file on screen

                    foreach (var text2 in ExtractFiles.AllFiles)
                    {
                        //everything wrapped in this to check that we haven't compared these two files before in this loop
                        if (!NotRepeatingMatches.Contains(text.Key + text2.Key))
                        {
                            //need this to stop it crashing
                            System.Threading.Thread.CurrentThread.Join(10);

                            //get shorttext to stop files in same path being checked 
                            string FolderPathNoFile2 = GetShortPath(text2.Key);

                            //if I want to compare files in the same folder then shorttext comparison must be FALSE so it thinks they are different folders
                            if (ExtractFiles.isSameFolder)
                            {
                                FolderPathNoFile2 = "Some Random value to fool checker thats its a different file";
                            }



                            //need to do contains before the rest as we stop repeats with NotRepeatingMatches
                            Boolean TContainsT2 = false;
                            Boolean T2ContainsT = false;
                            if (IsContains) //do it here so it only runs when contains = true and doesn't slow down loop
                            {
                                TContainsT2 = text.Value.Contains(text2.Value);
                                T2ContainsT = text2.Value.Contains(text.Value);
                            }

                            if (IsContains && (text.Key != text2.Key) && (TContainsT2 || T2ContainsT) && (FolderPathNoFile1 != FolderPathNoFile2))
                            {
                                count++;

                                ScreenResults.Add("Contains Text  -- " + GetShortPathWithFileName(text.Key) + " --  -- " + GetShortPathWithFileName(text2.Key));

                                FoundMatches.Add("Contains Text  | " + text.Key + " -- MATCHES WITH  -- " + text2.Key + @"\n\n");
                            }

                            //only compare files where the path is not exactly the same so we don't have the same person. && Don't run matches that have already been done
                            if ((text.Key != text2.Key) && !NotRepeatingMatches.Contains(text.Key + text2.Key) && (FolderPathNoFile1 != FolderPathNoFile2))
                            {
                                double levDist = Lev.Distance(text.Value, text2.Value);

                                if (levDist < LevSize)
                                {
                                    count++;

                                    ScreenResults.Add(levDist.ToString() + "  -- " + GetShortPathWithFileName(text.Key) + " --  -- " + GetShortPathWithFileName(text2.Key));

                                    FoundMatches.Add(levDist.ToString() + " | " + text.Key + " -- MATCHES WITH  -- " + text2.Key + @"\n\n");
                                }


                            }
                            //add the keys in reverse order so we can check them later (or earlier)to filter out matches that have been done
                            NotRepeatingMatches.Add(text2.Key + text.Key);
                        }
                    }
                }


            }
            catch (UnauthorizedAccessException uAEx)
            {
                Console.WriteLine(uAEx.Message);
            }
            catch (PathTooLongException pathEx)
            {
                Console.WriteLine(pathEx.Message);
            }


            //});
        }
        /// <summary>
        /// Short path without file name used to check if the files come from the same folder
        /// </summary>
        /// <param name="text">path</param>
        /// <returns></returns>
        private string GetShortPath(string text)
        {
            //get a short path without the filename for path comparisons
            int LastSlashText1 = text.Length - text.LastIndexOf(@"\");
            return text.Substring(0, text.Length - LastSlashText1);

        }
        /// <summary>
        /// Short string to appear on screen with file name but beginning truncated
        /// </summary>
        /// <param name="text">path</param>
        /// <returns></returns>
        private string GetShortPathWithFileName(string text)
        {
            return text.Substring(text.LastIndexOf(@"\") - 25);
        }

        /// <summary>
        /// Print out the data 
        /// </summary>
        /// <returns>Success / error message</returns>
        public string PrintResults()
        {
            try
            {
                string PathTitle = "Plagarism-Matches.txt";

                string path = Directory.GetCurrentDirectory();
                string docPath =
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

                //https://docs.microsoft.com/en-us/dotnet/api/system.io.file.writealllines?view=netframework-4.7.2
                File.WriteAllLines(Path.Combine(docPath, PathTitle), FoundMatches);

                return " File Printed look for Plagarism-Matches.txt on desktop";
            }
            catch (Exception e)
            {
                return " File not printed error" + e;
            }

        }


    }
}
